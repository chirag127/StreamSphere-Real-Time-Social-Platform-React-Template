# CI Pipeline for StreamSphere

# Description: This workflow automates the testing and building of the StreamSphere application.
# It ensures code quality, checks for potential issues, and prepares the application for deployment.
# Author: Apex Technical Authority
# Date: December 2025

name: CI Pipeline

# Trigger the workflow on push events to the main branch and on pull requests targeting the main branch.
# Also allows manual triggering for specific testing scenarios.

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # Allows manual triggering

jobs:
  # Job to set up the development environment and run linters and tests.
  build_and_test:
    name: Build and Test (Node.js)
    runs-on: ubuntu-latest # Use the latest Ubuntu runner for CI tasks.

    # Define the steps to be executed within this job.
    steps:
      # Step 1: Checkout the repository code.
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for reliable versioning and diffs.

      # Step 2: Set up Node.js environment.
      # Caches Node.js dependencies to speed up subsequent runs.
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20' # Use Node.js version 20.x, a stable LTS release.
          cache: 'npm' # Enable caching for npm packages.

      # Step 3: Install project dependencies.
      # Uses npm ci for faster, more reliable installs in CI environments.
      - name: Install Dependencies
        run: npm ci

      # Step 4: Run Linters and Formatters (using Biome as per Apex standards).
      # This step enforces code style and catches potential syntax errors early.
      - name: Run Linters and Formatters (Biome)
        run: npx @biomejs/biome format --check . && npx @biomejs/biome lint --apply . # Check formatting and linting, applying fixes if possible.

      # Step 5: Run Unit Tests (using Vitest).
      # Ensures individual components and functions work as expected.
      - name: Run Unit Tests (Vitest)
        run: npm test -- --coverage # Execute Vitest tests and generate code coverage report.

      # Step 6: Upload Code Coverage Reports.
      # Makes code coverage data accessible via Codecov.
      - name: Upload Coverage Reports to Codecov
        uses: codecov/codecov-action@v4
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }} # Use GitHub secrets for sensitive tokens.
        if: success() && github.ref == 'refs/heads/main' # Upload only on success for the main branch.

      # Step 7: Build the Project.
      # Compiles the frontend application using Vite.
      - name: Build Frontend Application
        run: npm run build
        env:
          NODE_ENV: production # Set Node.js environment to production for optimized builds.

      # Step 8: (Optional) Deploy to a Staging Environment (Example).
      # This is a placeholder and would typically involve deployment scripts or services.
      # - name: Deploy to Staging
      #   if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      #   run: echo "Deploying to staging..."
      #   # Add your deployment commands here, e.g., using a deployment script or service.

      # Step 9: (Optional) E2E Tests with Playwright.
      # Uncomment and configure if End-to-End tests are required.
      # - name: Run End-to-End Tests (Playwright)
      #   run: npm run test:e2e
      #   env:
      #     CI: true
      #     PLAYWRIGHT_BROWSERS_PATH: 0 # Ensure browsers are downloaded for the test environment.
